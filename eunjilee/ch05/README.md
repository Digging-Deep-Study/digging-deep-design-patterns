# 하나뿐인 특별한 객체 만들기, 싱글턴 패턴
"어떻게 하면 한 클래스의 인스턴스를 2개 이상 만들지 않게 하지?"

## 싱글턴 패턴(Singleton Pattern)
> 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공합니다.

## 멀티스레딩 문제를 해결하는 적절한 방법 선택하기
> getInstance() 메소드를 동기화하는 방법  
인스턴스를 시작하자마자 만드는 방법  
DCL을 쓰는 방법  
정적 내부 클래스를 사용하는 방법  
enum을 사용하는 방법

### 구현 방식 비교
| 방법 | 특징 | 장점 | 단점 | 선택 기준 |
|------|------|------|------|----------------|
| 1. `synchronized` getInstance() | 전체 메서드를 동기화 | 간단, thread-safe | 항상 락을 거니까 느림 | 성능 영향 없는 테스트/소규모 앱 |
| 2. Eager Initialization<br>`static final Singleton INSTANCE = new Singleton();` | 클래스 로딩 시 즉시 인스턴스 생성 | 구현 가장 간단, 안전 | Lazy 아님, 자원 낭비 가능 | 무조건 필요한 인스턴스일 때 |
| 3.  DCL (Double-Checked Locking) + `volatile` | 두 번 검사 + 부분 동기화 | Lazy + 동기화 최소화 | 구현 복잡, 실수 위험 | 고성능 & Lazy 모두 중요할 때 |
| 4. 정적 내부 클래스 방식<br>(Initialization-on-demand holder idiom) | 내부 클래스 로딩 시 인스턴스 생성 | Lazy + 안전 + 성능 + 간결 | JVM 동작 이해 필요 | 실무에서 가장 추천되는 방식 |
| 5. enum 기반 싱글턴<br>`enum Singleton { INSTANCE }` | enum 상수로 인스턴스 보장 | 가장 안전 (직렬화, 리플렉션도 안전) | Lazy 불가, 유연성 부족 | 보안 중시, 극한 안정성 필요 시 |
---

### 결론
- 실무에서는 정적 내부 클래스 방식이 가장 실용적이고 많이 사용된다.
- enum 방식은 가장 안전하지만, Lazy가 불가하고 유연성에 제약이 있을 수 있다.
- DCL은 복잡하고 오류 위험이 있어 최신 코드에서는 거의 사용되지 않는다.
- synchronized 방식은 간단하지만 성능 이슈로 실제 서비스에는 적합하지 않는다.


## [과제] 애플리케이션 설정 관리
> 전체 애플리케이션에서 읽기 전용 설정(환경 변수, 프로퍼티 파일)을 중앙에서 로드/제공
